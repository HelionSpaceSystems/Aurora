    # -*- coding: utf-8 -*-
    """
    Created on Sat Mar  5 09:03:47 2016
    
    @author: alib
    """
class trajectory:  
    def __init__:
        ''' Constructor for this class. '''
        
    def nominalPath(y,t,coast,vertAscent,pitchDuration,pitchRate,t_vertical,tVac,gravity,
                    planetRadius,rotRate,slDensity,slPressure,cl,refA,massFlow):
        
        # Create empty array dydt with equal length to u
        dydt = zeros_like(y)
        
       
         
        
    
        r = planetRadius + y[2]  
    
                                    # define orbital radius    
        instantPressure = earthAtmosphere.expdensity(y[2])       # calculate instantaneous pressure
        instantDensity =  earthAtmosphere.expdensity(y[2])       # calculate instantaneous density
        
        qInstant = aero_forces.dynamicPressure(instantDensity,y[3])
        D = aero_forces.drag(qInstant,refA,cd)
        L = aero_forces.lift(qInstant,refA,cl)
        machNum = aero_forces.machNumber(y[3],instantPressure,instantDensity) ##### FOX MEEEEE
    
        
        
        
    
        w_e = 0
        w_n = 0
       
        if t > t_vertical and t <= t_vertical+pitchDuration:
            alpha = pi/2 - y[4] - pitchRate*(t - t_vertical)
        else:
            alpha = 0
            
       # Calculate drag and lift      
    
        
    
    
        
        # Set Thrust = 0 if coast=True or set thrust to appropriate value given instantaneous pressure 
        if coast == False:
            T = tVac - instantPressure*.78
    
        else:
            T = 0
            massFlow =  0
            
    
        
        # Equations of motion during vertical ascent - modified to avoid divide by
        # zero errors originiating with the original equations of motion    
        if vertAscent == True:
            
            alpha = 0   
            dydt[0] = 0              
            dydt[1] = 0
            dydt[2] = y[3]
            dydt[3] = 1/y[6] * (T-D-y[6]*gravity) + r*rotRate**2
            dydt[4] = 0
            dydt[5] = 0
            dydt[6] = -massFlow
            
            
            # append instantaneous values to their respective list
            density.append(instantDensity)
            pressure.append(instantPressure)
            thrust.append(T)
            lift.append(L)
            AoA.append(alpha)
            time.append(t)
            q.append(qInstant)
    
            # print values of dydt and boolean conditions vertAscent and coast
         
         
        # assign appropriate thrust value given time of flight
        else:
            
        
            
            # powered ascent equations of motion without wind disturbance - note that wind will be added later
            dydt[0] = y[3]*cos(y[4])*cos(y[5])/(r*cos(y[1]))
            dydt[1] = y[3]*cos(y[4])*sin(y[5])/r
            dydt[2] = y[3]*sin(y[4])
            dydt[3] = 1/y[6] * (T*cos(alpha)-D-y[6]*gravity*sin(y[4])+w_e*cos(y[4])*cos(y[5])+w_n*cos(y[4])*sin(y[5])) + r*rotRate**2*cos(y[1])*(cos(y[1])*sin(y[4])-sin(y[1])*cos(y[4])*sin(y[5]))
            dydt[4] = 1/(y[6]*y[3])*((T*sin(alpha)+L)-y[6]*gravity*cos(y[4])-w_n*sin(y[4])*sin(y[5])-w_e*sin(y[4])*cos(y[5]))+y[3]*cos(y[4])/r+2*rotRate*cos(y[1])*cos(y[5])+r*rotRate**2/y[3]*cos(y[1])*(cos(y[1])*cos(y[4])+sin(y[1])*sin(y[4])*sin(y[5])) 
            dydt[5] = -1/(y[6]*y[3]*cos(y[4]+.0001))*((T*sin(alpha)+L)+w_e*sin(y[5])-w_n*cos(y[5]))-y[3]/r*tan(y[1])*cos(y[4])*cos(y[5])+2*rotRate*(cos(y[1])*tan(y[4])*sin(y[5])-sin(y[1]))-r*rotRate**2/(y[3]*cos(y[4]))*cos(y[1])*sin(y[1])*cos(y[5])#0.0001 us there to avoid a divide by zero, prolly should go back and fix this at some point
            dydt[6] = -massFlow
            
            
            # append instantaneous values to their respective list
            density.append(instantDensity)
            pressure.append(instantPressure)
            thrust.append(T)
            lift.append(L)
            AoA.append(alpha)
            time.append(t)
            q.append(qInstant)
    
    
           
        return dydt
